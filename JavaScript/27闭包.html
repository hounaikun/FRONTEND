<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
        /*
        * 1.如何产生闭包？
        *   当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
        * 2.闭包到底是什么？
        *   *使用chrome调试查看
        *   理解一、闭包是嵌套的内部函数（绝大部分人）
        *   理解二、包含被引用变量（函数）的对象（极少数人）
        *   注意：闭包存在于嵌套的内部函数中
        * 3.产生闭包的条件
        *   函数嵌套
        *   &&
        *   内部函数引用了外部函数的数据（变量/函数）
        * */
        function f1() {
            var a = 2;
            function f2() { //执行函数定义就会产生闭包（不用调用函数）
                console.log(a++)
            }
            return f2;
        }
       var f = f1();

        /*
        * 闭包的作用
        *   1.使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
        *   2.让函数外部可以操作（读写）到函数内部的数据（变量/函数）
        * 问题：
        *   1.函数执行完后，函数内部声明的局部变量是否还存在？
        *       一般是不存在，存在于闭包中的变量才可能存在
        *   2.在函数外部能直接访问函数内部的局部变量吗？
        *       不能，但我们可以通过闭包让外部操作它，举例如下
        * */
        function p() {
            var a = 2;
            function setA(b) { //执行函数定义就会产生闭包（不用调用函数）
                a = b;
            }
            function getA() {
                return a;
            }
            return {setA:setA,getA:getA};
        }
        var f = p();
        f.setA(10);
        console.log(f.getA());

        /*
        * 闭包的缺点：
        *   函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
        *   容易造成内存泄漏
        * 解决：
        *   能不用闭包就不用
        *   即使释放
        * */
    </script>
</body>
</html>